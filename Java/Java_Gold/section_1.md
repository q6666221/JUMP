#### switch文の基本

指定类型

1. 基本类型：byte，short，int，char

2. Rapper：Byte，Short，Integer，Character

3. 其他：enum，String

#### リテラル

```Java
int val1 = 26; // 10进制
int val2 = 032; // 8进制
int val3 = 0x1a; // 16进制
int val4 = 0b11010; // 2进制
```

#### アンダースコア

使用範囲

- 先頭、末尾に使用できない

- 符号（0x、0b、浮動小数点、**F・ｆ**、**L・ｌ**、**D・ｄ**）の前後に使用できない

　コメント：**太字**はfloat、long、double末尾要素

#### アクセス修飾子

|修飾子|クラス|コンストラクタ|メンバ変数|メソッド|
|-|-|-|-|-|
|public|〇|〇|〇|〇|
|protected|✕|〇|〇|〇|
|デフォルト（指定なし）|〇|〇|〇|〇|
|private|✕|〇|〇|〇|

#### カプセル化

オブジェクト指向言語では、**属性と操作を一体化**させて表現することをカブセル化と呼びます

#### JavaBeansとイミュータブルオブジェクト[^1]

**JavaBeans**

- メンバ変数はprivateとし、外部からはgetter[^2]メソッドとsetter[^3]メソッドを通じてのみアクセス可能とする
- boolean型のメンバ変数に対するgetterは、getXX()の他、isXX()としてもよい

**イミュータブルオブジェクト**

- クラスが拡張できないことを保証するためfinalクラスとする
  または、getterメソッドにfinalを付与しオーバライドさせない
- メンバ変数はprivate、final修飾にする
- オブジェクトの状態を変更するようなメソッドは定義しない、例えば、setter
- メンバ変数に参照型の変更可能なオブジェクトを持つ場合、変更されないよう配慮する

![image-20201224162406328](C:\Users\zzq\AppData\Roaming\Typora\typora-user-images\image-20201224162406328.png)

堅牢性の向上

保守性の向上：カブセル化されていればクラスの内部の変更が外部に与える影響を最小化できる

#### final修飾子とstatic修飾子

**final**

| 適用箇所 | 意味                                 |
| :------- | ------------------------------------ |
| クラス   | サブクラスは作成できない             |
| メソッド | サブクラス側でオーバーライドできない |
| 変数     | 定数となる                           |

**static**

| 適用箇所 | 意味                                                         | 呼び出し                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| メソッド | クラスメソッド                                               | **クラス名**も**オブジェクト名**も呼び出される               |
| 変数     | クラス変数                                                   | **クラス名**も**オブジェクト名**も呼び出される               |
| ブロック | イニシャライズブロック<br />staticイニシャライズ[^4]と呼ぶ。<br />イニシャライズ[^5]と違う | 呼び出されない。<br />クラスをロードすると、ロードされたもの |

#### インスタンスメンバとstaticメンバのクラス内でのアクセス

- インスタンスメンバは、staticメンバに直接アクセスできる
- staticメンバは、インスタンスメンバに直接アクセスできない。アクセスする場合は、**インスタンス化してからアクセスする**

#### デザインパターン

**設計の原則**

> 悪い例
> 凝集度[^6]は低いこと。仕様変更が生じた場合の影響範囲が広くなってしまう。
>
> 良い例
> 疎結合[^7]があり、あるクラスの実装を変更しても、ほかのクラスに影響を及ぼしないこと。
>
> 纏め
> 凝集度は低くて疎結合は強いことを、好ましい設計といえます。
> 保守性、拡張性のクラスを作成するために

以下に４点のみ掲載します：

- 正確性：仕様を正しく満たしていること
- 統一性：設計上の個々の概念が統一されていること
- 可読性：設計の成果物が読みやすく理解しやすいこと
- 変更容易性：修正が容易であること

#### デザインパターン[^8]

**シングルトンパターン**

システムを稼働している際に、あるクラスのオブジェクトは一つ存在しかないことを保証したいというケースです。これはシングルスレッドの場合です。マルチスレッドの場合は、synchronized修飾子を付与した方がいいです。

**イミュータブルオブジェクト**

読み取り専用のオブジェクトを作成したい場合


#### 列挙型

> 特定の値のみを持つ型で、プログラマが任意に定義できます。
> 列挙型は、クラス定義の中、あるいは列挙型の定義だけを記述したソースファイルで定義できます。ただし、メソッドの中で定義することはできません。
> java.lang.Enumクラスを継承したfinalクラスです。

#### Enumクラス

```java
enum Card1 {
    SPADES, CLUBS, DIAMONDS, HEARTS;
}

// 以下のようなもの。実にはこんなものを定義できない
final class Card1 extends Enum<Card1> {
    public static final Card1 SPADES;
    public static final Card1 CLUBS;
    public static final Card1 DIAMONDS;
    public static final Card1 HEARTS;
}
```

主なメソッド

| メソッド名                                                   | 説明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **final** String name()                                      | enum定数の名前を返す                                         |
| String toString()                                            | enum定数の名前を返す。name()との区別はオーバーライドできるかどうかのみ |
| **final** boolean equals(Object other)                       | 指定されたオブジェクトがこのenum定数と同じ場合は、trueを返す |
| **final** int hashCode()                                     | enum定数のハッシュコードを返す                               |
| **static**  <T extends Enum< T >> T valueOf(Class< T > enumType, String name) | 指定された名前をもつ、指定されたenum型のenum定数を返す       |
| **final** int ordinal()                                      | 列挙宣言での位置を返す                                       |

#### 列挙型でのコンストラクタ、変数、メソッド定義

```java
enum Card2 {
    // 列挙のインスタンス、列挙の先頭行に定義しなければならない
    // 前に何か修飾子を追加できない
    SPADES(3), CLUBS(1), DIAMONDS(4), HEARTS(2);
    // 変数
    private int val;
    // コンストラクタ
    Card2(int val) {
        this.val = val;
    }
    // メソッド
    public int getVal() {
        return this.val;
    }
}

class EnumTest {
    public static void main(String[] args) {
        // EnumにはComparableから継承してオーバライドしたもの
        Card2[] c = Card2.values();
    }
}
```

**列挙の継承**

> values()などのメソッドはjava.lang.annotationパッケージでのElementTypeに継承されたものです。コンパイルの時、追加されたものです。

**ポイント**

- 列挙型の定義では、enumキーワードを使用する
- クラスと同様に、コンストラクタ、メソッド、メンバ変数を定義できる
- コンパイルするとクラスファイルが生成される
- シングルトンのものなんです
- 列挙型を継承できない
- 抽象メソッドの利用や、インタフェースの実装は可能
- 列挙型は、Comparableインタフェースを実装しており、各定数は列記した順番で管理される

#### Objectクラス

> java.lang.Objectクラスは、Javaのクラス階層を構成するためのルートとなるクラスです。
> すべてのクラスは、Objectクラスの配下に位置します。

| メソッド名                 | 説明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| boolean equals(Object obj) | 自オブジェクトと渡したのを比較し、イコールの場合はtrue返す   |
| final Class<?> getClass()  | このオブジェクトの実行時クラスを返す                         |
| int hashCode()             | オブジェクトのハッシュコード値を返す                         |
| String toString()          | オブジェクトの文字列表現を返す                               |
| void finalize()            | オブジェクトへの参照がないとガベージコレクタによって判断されたときに、ガベージコレクタによって、呼び出される |

```java
obj1.equals(obj2); // false
obj1.hashCode() == obj2.hashCode(); // true,false両方もあり、ハッシュで計算してから
```

tips

> **equals()**メソッドでは、引数で受け取ったオブジェクトが自オブジェクトの型をもつかどうか、**instanceof**演算子で確認した後、オブジェクトのインスタンス値を比較する

#### staticインポート

​	構文

> ①　**import** **static** パッケージ名.クラス名.**static**変数名;
> 　　完全修飾名で指定されたクラスにあるstatic変数をstaticインポートする
>
> ②　**import** **static** パッケージ名.クラス名.**static**メソッド名;
> 　　完全修飾名で指定されたクラスにあるstaticメソッドをstaticインポートする
>
> ③　**import** **static** パッケージ名.クラス名.＊;
> 　　完全修飾名で指定されたクラスにあるすべてのstaticメンバをstaticインポートする





**注釈**

[^1]: Immutable object、不変オブジェクト、反対はmmutable object、可変オブジェクト。
[^2]: getで始まり、メンバ変数名が続くものであり、例えば「getName()」のようなものです。getterの戻り値は対尾するメンバ変数の型に一致し、引数は持たない。
[^3]: setで始まり、メンバ変数名が続くものであり、例えば「setName(name)」のようなものです。setterの戻り値は持たないし、引数は対応するメンバ変数の型に一致する。 
[^4]: staticイニシャライズはクラスファイルがロードされたタイミングで一度だけ実行されるブロックです。例：`static { }`
[^5]: コンパイル時、すべてのコンストラクタにコピーする。例：`{ }`
[^6]: クラスの機能と属性とか各クラスの間とかの関連性の強さを表す。適切なクラス分割がされていないと、互いに関連する機能や属性があちこちに分散し、凝集度は低い。
[^7]: オブジェクト間の依存性が低いこと。
[^8]: パターンは「ある文脈の問題に対して、繰り返し適用可能な解決策」と定義されていますし、多くの人の経験や情報をもとに作られた、様々なケースに適用可能な解決策です。ソフトウエアの分野では、パターンを「デザインパターン」とも呼びます。

